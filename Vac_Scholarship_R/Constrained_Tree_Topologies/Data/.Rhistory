Expected_Return3[i] <- temp$pm  # Insert print(vpm) to see how the for loop creates vpm
Standard_Deviation3[i] <- temp$ps
mweights3[i, ] <-temp$pw
}
head(mweights3)
tail(mweights3)
grid5 <- seq(from = 0.006839, to = 0.01241 , length.out = 10000)
grid5
Expected_Return3 <- Standard_Deviation3 <- rep(NA, times = 10000) # 50 b/c 50 target returns were created in grid
mweights3 <- matrix(NA, 10000, 4) # 50 & 4 b/c a weight is to be found for each of 4 stocks (columns) given each of 50 target return (rows)
for(i in 1:length(grid5)){
temp <- portfolio.optim(x = returns, shorts = TRUE, pm = grid5[i], reshigh = max_weights1, reslow = min_weights1)
Expected_Return3[i] <- temp$pm  # Insert print(vpm) to see how the for loop creates vpm
Standard_Deviation3[i] <- temp$ps
mweights3[i, ] <-temp$pw
}
head(mweights3)
tail(mweights3)
grid5 <- seq(from = 0.006839, to = 0.012405 , length.out = 10000)
grid5
Expected_Return3 <- Standard_Deviation3 <- rep(NA, times = 10000) # 50 b/c 50 target returns were created in grid
mweights3 <- matrix(NA, 10000, 4) # 50 & 4 b/c a weight is to be found for each of 4 stocks (columns) given each of 50 target return (rows)
for(i in 1:length(grid5)){
temp <- portfolio.optim(x = returns, shorts = TRUE, pm = grid5[i], reshigh = max_weights1, reslow = min_weights1)
Expected_Return3[i] <- temp$pm  # Insert print(vpm) to see how the for loop creates vpm
Standard_Deviation3[i] <- temp$ps
mweights3[i, ] <-temp$pw
}
head(mweights3)
tail(mweights3)
grid5 <- seq(from = 0.006839, to = 0.0124047 , length.out = 10000)
grid5
Expected_Return3 <- Standard_Deviation3 <- rep(NA, times = 10000) # 50 b/c 50 target returns were created in grid
mweights3 <- matrix(NA, 10000, 4) # 50 & 4 b/c a weight is to be found for each of 4 stocks (columns) given each of 50 target return (rows)
for(i in 1:length(grid5)){
temp <- portfolio.optim(x = returns, shorts = TRUE, pm = grid5[i], reshigh = max_weights1, reslow = min_weights1)
Expected_Return3[i] <- temp$pm  # Insert print(vpm) to see how the for loop creates vpm
Standard_Deviation3[i] <- temp$ps
mweights3[i, ] <-temp$pw
}
head(mweights3)
tail(mweights3)
grid5 <- seq(from = 0.006839, to = 0.0124043 , length.out = 10000)
grid5
Expected_Return3 <- Standard_Deviation3 <- rep(NA, times = 10000) # 50 b/c 50 target returns were created in grid
mweights3 <- matrix(NA, 10000, 4) # 50 & 4 b/c a weight is to be found for each of 4 stocks (columns) given each of 50 target return (rows)
for(i in 1:length(grid5)){
temp <- portfolio.optim(x = returns, shorts = TRUE, pm = grid5[i], reshigh = max_weights1, reslow = min_weights1)
Expected_Return3[i] <- temp$pm  # Insert print(vpm) to see how the for loop creates vpm
Standard_Deviation3[i] <- temp$ps
mweights3[i, ] <-temp$pw
}
head(mweights3)
tail(mweights3)
grid5 <- seq(from = 0.006839, to = 0.012404 , length.out = 10000)
grid5
Expected_Return3 <- Standard_Deviation3 <- rep(NA, times = 10000) # 50 b/c 50 target returns were created in grid
mweights3 <- matrix(NA, 10000, 4) # 50 & 4 b/c a weight is to be found for each of 4 stocks (columns) given each of 50 target return (rows)
for(i in 1:length(grid5)){
temp <- portfolio.optim(x = returns, shorts = TRUE, pm = grid5[i], reshigh = max_weights1, reslow = min_weights1)
Expected_Return3[i] <- temp$pm  # Insert print(vpm) to see how the for loop creates vpm
Standard_Deviation3[i] <- temp$ps
mweights3[i, ] <-temp$pw
}
head(mweights3)
tail(mweights3)
grid5 <- seq(from = 0.006839, to = 0.012402 , length.out = 10000)
grid5
Expected_Return3 <- Standard_Deviation3 <- rep(NA, times = 10000) # 50 b/c 50 target returns were created in grid
mweights3 <- matrix(NA, 10000, 4) # 50 & 4 b/c a weight is to be found for each of 4 stocks (columns) given each of 50 target return (rows)
for(i in 1:length(grid5)){
temp <- portfolio.optim(x = returns, shorts = TRUE, pm = grid5[i], reshigh = max_weights1, reslow = min_weights1)
Expected_Return3[i] <- temp$pm  # Insert print(vpm) to see how the for loop creates vpm
Standard_Deviation3[i] <- temp$ps
mweights3[i, ] <-temp$pw
}
head(mweights3)
tail(mweights3)
grid5 <- seq(from = 0.006839, to = 0.012403 , length.out = 10000)
grid5
Expected_Return3 <- Standard_Deviation3 <- rep(NA, times = 10000) # 50 b/c 50 target returns were created in grid
mweights3 <- matrix(NA, 10000, 4) # 50 & 4 b/c a weight is to be found for each of 4 stocks (columns) given each of 50 target return (rows)
for(i in 1:length(grid5)){
temp <- portfolio.optim(x = returns, shorts = TRUE, pm = grid5[i], reshigh = max_weights1, reslow = min_weights1)
Expected_Return3[i] <- temp$pm  # Insert print(vpm) to see how the for loop creates vpm
Standard_Deviation3[i] <- temp$ps
mweights3[i, ] <-temp$pw
}
head(mweights3)
tail(mweights3)
grid5 <- seq(from = 0.006839, to = 0.0124025 , length.out = 10000)
grid5
Expected_Return3 <- Standard_Deviation3 <- rep(NA, times = 10000) # 50 b/c 50 target returns were created in grid
mweights3 <- matrix(NA, 10000, 4) # 50 & 4 b/c a weight is to be found for each of 4 stocks (columns) given each of 50 target return (rows)
for(i in 1:length(grid5)){
temp <- portfolio.optim(x = returns, shorts = TRUE, pm = grid5[i], reshigh = max_weights1, reslow = min_weights1)
Expected_Return3[i] <- temp$pm  # Insert print(vpm) to see how the for loop creates vpm
Standard_Deviation3[i] <- temp$ps
mweights3[i, ] <-temp$pw
}
head(mweights3)
tail(mweights3)
Expected_Return3
head(Expected_Return3)
Standard_Deviation3
Expected_Return3  <- na.omit(Expected_Return3 )
Standard_Deviation3 <- na.omit(Standard_Deviation3)
mweights3 <- na.omit(mweights3)
vsr3 <- (Expected_Return3  - rf) / Standard_Deviation3
vsr3
weights_max_sr3 <- mweights3[vsr3 == max(vsr3),]
weights_max_sr3
Row3 <- which.max(vsr3)
Row3
ER_opt3 <- Expected_Return3[Row3]
ER_opt3
sigma_opt3 <- Standard_Deviation3[Row3]
sigma_opt3
Standard_Deviation3 <- Standard_Deviation3*sqrt(12)
Expected_Return3 <- 12*(exp(Expected_Return3)-1)
vsr_max3 <- (Expected_Return3[vsr3 == max(vsr3)]-0.0227 )/ Standard_Deviation3[vsr3 == max(vsr3)]
vsr_max3
weights_minvar3 <- mweights3[Standard_Deviation3 == min(Standard_Deviation3), ]
weights_minvar3
ER_minvar3 <- Expected_Return3[Standard_Deviation3 == min(Standard_Deviation3)]
SD_minvar3 <- Standard_Deviation3[Standard_Deviation3 == min(Standard_Deviation3)]
df5 <- cbind(Standard_Deviation3,Expected_Return3)
df5 <- as.data.frame(df5)
colnames(df5) <- c("Standard_Deviation","Expected_Return")
df5
tail(df5)
grid6 <- seq(from = 0, to = 0.3 , length.out = 10000)
grid6
y3 <-  rep(NA, times = 10000)
y3
for(i in 1:length(grid6)){
y3[i] <- 0.027 + vsr_max3*grid6[i]  # Insert print(vpm) to see how the for loop creates vpm
}
y3
df6 <- cbind(grid6,y3)
df6 <- as.data.frame(df6)
colnames(df6) <- c("Standard_Deviation","Expected_Return")
DF3 <- rbind(df5, df6)
DF3 <- na.omit(DF3)
DF3
tail(DF3)
plot3 <- ggplot(DF3, aes(Standard_Deviation, Expected_Return ))+geom_point(size=0.1)
plot3
plot3 <- plot3 + scale_x_continuous(limits = c(0, 0.2))+ scale_y_continuous(limits = c(0, 0.2))
plot3
Expected_Return3
head(Expected_Return3)
Standard_Deviation3
grid5 <- seq(from = 0.006839, to = 0.0124025 , length.out = 10000)
grid5
Expected_Return3 <- Standard_Deviation3 <- rep(NA, times = 10000) # 50 b/c 50 target returns were created in grid
mweights3 <- matrix(NA, 10000, 4) # 50 & 4 b/c a weight is to be found for each of 4 stocks (columns) given each of 50 target return (rows)
for(i in 1:length(grid5)){
temp <- portfolio.optim(x = returns, shorts = TRUE, pm = grid5[i], reshigh = max_weights1, reslow = min_weights1)
Expected_Return3[i] <- temp$pm  # Insert print(vpm) to see how the for loop creates vpm
Standard_Deviation3[i] <- temp$ps
mweights3[i, ] <-temp$pw
}
head(mweights3)
tail(mweights3)
Expected_Return3
head(Expected_Return3)
Standard_Deviation3
Expected_Return3  <- na.omit(Expected_Return3 )
Standard_Deviation3 <- na.omit(Standard_Deviation3)
mweights3 <- na.omit(mweights3)
vsr3 <- (Expected_Return3  - rf) / Standard_Deviation3
vsr3
Row3 <- which.max(vsr3)
Row3
vsr3
ER_opt3 <- Expected_Return3[Row3]
ER_opt3
sigma_opt3 <- Standard_Deviation3[Row3]
sigma_opt3
Standard_Deviation3 <- Standard_Deviation3*sqrt(12)
Expected_Return3 <- 12*(exp(Expected_Return3)-1)
ER_opt3 <- Expected_Return3[Row3]
ER_opt3
sigma_opt3 <- Standard_Deviation3[Row3]
sigma_opt3
vsr_max3 <- (Expected_Return3[Row3]-0.0227 )/ Standard_Deviation3[Row3]
vsr_max3
weights_minvar3 <- mweights3[Standard_Deviation3 == min(Standard_Deviation3), ]
weights_minvar3
ER_minvar3 <- Expected_Return3[Standard_Deviation3 == min(Standard_Deviation3)]
SD_minvar3 <- Standard_Deviation3[Standard_Deviation3 == min(Standard_Deviation3)]
df5 <- cbind(Standard_Deviation3,Expected_Return3)
df5 <- as.data.frame(df5)
colnames(df5) <- c("Standard_Deviation","Expected_Return")
df5
tail(df5)
grid6 <- seq(from = 0, to = 0.3 , length.out = 10000)
grid6
y3 <-  rep(NA, times = 10000)
y3
for(i in 1:length(grid6)){
y3[i] <- 0.027 + vsr_max3*grid6[i]  # Insert print(vpm) to see how the for loop creates vpm
}
y3
df6 <- cbind(grid6,y3)
df6 <- as.data.frame(df6)
colnames(df6) <- c("Standard_Deviation","Expected_Return")
DF3 <- rbind(df5, df6)
DF3 <- na.omit(DF3)
DF3
tail(DF3)
plot3 <- ggplot(DF3, aes(Standard_Deviation, Expected_Return ))+geom_point(size=0.1)
plot3
plot3 <- plot3 + scale_x_continuous(limits = c(0, 0.2))+ scale_y_continuous(limits = c(0, 0.2))
plot3
grid6 <- seq(from = 0, to = 0.3 , length.out = 10000)
grid6
y3 <-  rep(NA, times = 10000)
y3
for(i in 1:length(grid6)){
y3[i] <- 0.0227 + vsr_max3*grid6[i]  # Insert print(vpm) to see how the for loop creates vpm
}
y3
df6 <- cbind(grid6,y3)
df6 <- as.data.frame(df6)
colnames(df6) <- c("Standard_Deviation","Expected_Return")
DF3 <- rbind(df5, df6)
DF3 <- na.omit(DF3)
DF3
tail(DF3)
plot3 <- ggplot(DF3, aes(Standard_Deviation, Expected_Return ))+geom_point(size=0.1)
plot3
plot3 <- plot3 + scale_x_continuous(limits = c(0, 0.2))+ scale_y_continuous(limits = c(0, 0.2))
plot3
plot3 <- plot3 + ggtitle("Efficient Frontier with IPS Constraints")+theme_economist()+ scale_colour_economist()
plot3 <- plot3 + annotate(geom="text",x=0.07, y=0.13, label="Optimal Portfolio (0.1141,0.1269)", color='black')
plot3 <- plot3 + annotate("point", x =Standard_Deviation3[Row3], y =Expected_Return3[Row3] , colour = "red",size=2)
plot3
ER_opt3
sigma_opt3
vsr_max3
weights_minvar3
plot3 <- ggplot(DF3, aes(Standard_Deviation, Expected_Return ))+geom_point(size=0.1)
plot3
plot3 <- plot3 + scale_x_continuous(limits = c(0, 0.2))+ scale_y_continuous(limits = c(0, 0.2))
plot3 <- plot3<- plot3 + annotate(geom="text",x=0.085, y=0.165, label="Optimal Risky Portfolio (0.14724,0.13292)", color='black')
plot3 <- plot3 + ggtitle("Efficient Frontier with IPS Constraints and CML")+theme_economist()+ scale_colour_economist()
plot3 <- plot3 + annotate(geom="text",x=0.07, y=0.13, label="Optimal Portfolio (0.1141,0.1269)", color='black')
plot3 <- plot3 + annotate("point", x =Standard_Deviation3[Row3], y =Expected_Return3[Row3] , colour = "red",size=2)
plot3
plot3 <- ggplot(DF3, aes(Standard_Deviation, Expected_Return ))+geom_point(size=0.1)
plot3
plot3 <- plot3 + scale_x_continuous(limits = c(0, 0.2))+ scale_y_continuous(limits = c(0, 0.2))
plot3 <- plot3 + annotate(geom="text",x=0.085, y=0.165, label="Optimal Risky Portfolio (0.14724,0.13292)", color='black')
plot3 <- plot3 + ggtitle("Efficient Frontier with IPS Constraints and CML")+theme_economist()+ scale_colour_economist()
plot3 <- plot3 + annotate(geom="text",x=0.07, y=0.13, label="Optimal Portfolio (0.1141,0.1269)", color='black')
plot3 <- plot3 + annotate("point", x =Standard_Deviation3[Row3], y =Expected_Return3[Row3] , colour = "red",size=2)
plot3
plot3 <- ggplot(DF3, aes(Standard_Deviation, Expected_Return,colour=Plot ))+geom_point(size=0.1)
plot3
plot3 <- plot3 + scale_x_continuous(limits = c(0, 0.2))+ scale_y_continuous(limits = c(0, 0.2))
plot3 <- plot3 + annotate(geom="text",x=0.085, y=0.165, label="Optimal Risky Portfolio (0.14724,0.13292)", color='black')
plot3 <- plot3 + ggtitle("Efficient Frontier with IPS Constraints and CML")+theme_economist()+ scale_colour_economist()
plot3 <- plot3 + annotate("point", x =Standard_Deviation3[Row3], y =Expected_Return3[Row3] , colour = "red",size=2)
plot3 <- plot3 +
guides(colour =guide_legend(override.aes = list(size=1.5))) +  xlab("Annual Standard Deviation") + ylab("Annual Expected Return ")
plot3 <- plot3 + geom_vline(xintercept = 0.1,linetype="dotted")
plot3
plot3 <- ggplot(DF3, aes(Standard_Deviation, Expected_Return,colour=Plot ))+geom_point(size=0.1)
for(i in 1:length(grid6)){
y3[i] <- 0.0227 + vsr_max3*grid6[i]  # Insert print(vpm) to see how the for loop creates vpm
}
y3
df6 <- cbind(grid6,y3)
df6 <- as.data.frame(df6)
colnames(df6) <- c("Standard_Deviation","Expected_Return")
df6$Plot <- "CML"
df5$Plot <- "IPS_Frontier"
DF3 <- rbind(df5, df6)
DF3 <- na.omit(DF3)
DF3
tail(DF3)
plot3 <- ggplot(DF3, aes(Standard_Deviation, Expected_Return,colour=Plot ))+geom_point(size=0.1)
plot3
plot3 <- plot3 + scale_x_continuous(limits = c(0, 0.2))+ scale_y_continuous(limits = c(0, 0.2))
plot3 <- plot3 + annotate(geom="text",x=0.085, y=0.165, label="Optimal Risky Portfolio (0.14724,0.13292)", color='black')
plot3 <- plot3 + ggtitle("Efficient Frontier with IPS Constraints and CML")+theme_economist()+ scale_colour_economist()
plot3 <- plot3 + annotate("point", x =Standard_Deviation3[Row3], y =Expected_Return3[Row3] , colour = "red",size=2)
plot3 <- plot3 +
guides(colour =guide_legend(override.aes = list(size=1.5))) +  xlab("Annual Standard Deviation") + ylab("Annual Expected Return ")
plot3 <- plot3 + geom_vline(xintercept = 0.1,linetype="dotted")
plot3
plot3 <- ggplot(DF3, aes(Standard_Deviation, Expected_Return,colour=Plot ))+geom_point(size=0.1)
plot3
plot3 <- plot3 + scale_x_continuous(limits = c(0, 0.2))+ scale_y_continuous(limits = c(0, 0.2))
plot3 <- plot3 + annotate(geom="text",x=0.07, y=0.145, label="Optimal Risky Portfolio (0.14724,0.13292)", color='black')
plot3 <- plot3 + ggtitle("Efficient Frontier with IPS Constraints and CML")+theme_economist()+ scale_colour_economist()
plot3 <- plot3 + annotate("point", x =Standard_Deviation3[Row3], y =Expected_Return3[Row3] , colour = "red",size=2)
plot3 <- plot3 +
guides(colour =guide_legend(override.aes = list(size=1.5))) +  xlab("Annual Standard Deviation") + ylab("Annual Expected Return ")
plot3 <- plot3 + geom_vline(xintercept = 0.1,linetype="dotted")
plot3
plotg <- plot3+ geom_hline(yintercept = 0.08,linetype="dotted")
plotg
plot3 <- plot3 + annotate(geom="text",x=0.01, y=0.05, label="rf=0.0227", color='black') +annotate("point", x =0, y =0.0227 , colour = "red",size=2)
plot3
plot3
plotg <- plot3+ geom_hline(yintercept = 0.08,linetype="dotted")
plotg
weights_minvar3
vsr_max3
source('~/Documents/PTM/Tex/PTM.R', echo=TRUE)
library("ape")
library("Biostrings")
library("ggplot2")
library("ggtree")
require("ape")
install.packages("ape")
install.packages("Biostrings")
install.packages("ggtree")
install.packages(c("devtools", "withr"))
setwd("~/Documents/root_node/Vac_Scholarship_R/Constrained_Tree_Topologies/Data")
source('~/Documents/root_node/Vac_Scholarship_R/Constrained_Tree_Topologies/Testing_Trees_Functions.R', echo=TRUE)
Complex <- read.phyDat("Complex.fa",format="fasta", type="DNA")
Complex <- read.phyDat("Complex.fa",format="fasta", type="DNA")
n<- length(Complex)
names<- c(rep(1:n))
for( i in 1:n) {
names[i] <- paste( i, 1, sep = ".")
}
names(Complex) <- names
ML3(t3,Complex,T3,0.001)
t3 <- c(1,1,1)
ML3(t3,Complex,T3,0.001)
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
n<- length(Complex)
names<- c(rep(1:n))
for( i in 1:n) {
names[i] <- paste( i, 1, sep = ".")
}
names(Complex3) <- names
Complex2 <- Complex3[c(1,2)]
ML3(t3,Complex3,T3,0.001)
t <- 1
ML2(t,Complex2,T2,0.001)
Sd <- as.DNAbin(Complex)
DM<- dist.dna(Sd,model="JC69", as.matrix = TRUE)
DM
Sd <- as.DNAbin(Complex)
DM<- dist.dna(Sd,model="JC69", as.matrix = TRUE)
DM
DM
DMraw<- dist.dna(Sd,model="raw", as.matrix = TRUE)
DMraw
sub<- DMraw[3,1:2]
minpositive = function(x) min(x[x > 0])
av.distance<-mean(sub) # av distance near 0.75 suggests near random evolution
max.distance <-max(sub)
min.distance <-minpositive(sub)
sub.in<- DMraw[1:2,1:2]
av.distance.in<-mean(sub.in)
max.distance.in <-max(sub.in)
min.distance.in <-minpositive(sub.in)
Sd <- as.DNAbin(Complex3)
DMraw<- dist.dna(Sd,model="raw", as.matrix = TRUE)
DMraw
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
Complex2 <- Complex3[c(1,2)]
n<- length(Complex)
names<- c(rep(1:n))
for( i in 1:n) {
names[i] <- paste( i, 1, sep = ".")
}
names(Complex3) <- names
ML3(t3,Complex3,T3,0.001)
ML2(t,Complex2,T2,0.001)
Sd <- as.DNAbin(Complex3)
DMraw<- dist.dna(Sd,model="raw", as.matrix = TRUE)
DMraw
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
Complex2 <- Complex3[c(1,2)]
n<- length(Complex)
names<- c(rep(1:n))
for( i in 1:n) {
names[i] <- paste( i, 1, sep = ".")
}
names(Complex3) <- names
ML3(t3,Complex3,T3,0.001)
ML2(t,Complex2,T2,0.001)
Sd <- as.DNAbin(Complex3)
DMraw<- dist.dna(Sd,model="raw", as.matrix = TRUE)
DMraw
Complex3
length(Complex3)
length(Complex3)
length(Complex3[1])
length(Complex3[[1]])
DMraw <- length(Complex3[[1]])
DMraw<- dist.dna(Sd,model="raw", as.matrix = TRUE)
DMraw <- DMraw * length(Complex3[[1]])
DMraw <- DMraw / 10000000
DMraw
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
Complex2 <- Complex3[c(1,2)]
n<- length(Complex)
names<- c(rep(1:n))
for( i in 1:n) {
names[i] <- paste( i, 1, sep = ".")
}
names(Complex3) <- names
ML3(t3,Complex3,T3,0.001)
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
Change names
n<- length(Complex)
names<- c(rep(1:n))
for( i in 1:n) {
names[i] <- paste( i, 1, sep = ".")
}
names(Complex3) <- names
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
n<- length(Complex)
names<- c(rep(1:n))
for( i in 1:n) {
names[i] <- paste( i, 1, sep = ".")
}
names(Complex3) <- names
Complex2 <- Complex3[c(1,2)]
ML3(t3,Complex3,T3,0.001)
ML2(t,Complex2,T2,0.001)
length(Complex3[[1]])
Sd <- as.DNAbin(Complex3)
DMraw<- dist.dna(Sd,model="raw", as.matrix = TRUE)
DMraw <- DMraw * length(Complex3[[1]])
DMraw <- DMraw / 10000000
DMraw
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
n<- length(Complex)
names<- c(rep(1:n))
for( i in 1:n) {
names[i] <- paste( i, 1, sep = ".")
}
names(Complex3) <- names
Complex2 <- Complex3[c(1,2)]
ML3(t3,Complex3,T3,0.001)
ML2(t,Complex2,T2,0.001)
length(Complex3[[1]])
Sd <- as.DNAbin(Complex3)
DMraw<- dist.dna(Sd,model="raw", as.matrix = TRUE)
DMraw <- DMraw * length(Complex3[[1]])
DMraw <- DMraw / 10000000
DMraw
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
n<- length(Complex)
names<- c(rep(1:n))
for( i in 1:n) {
names[i] <- paste( i, 1, sep = ".")
}
names(Complex3) <- names
Complex2 <- Complex3[c(1,2)]
ML3(t3,Complex3,T3,0.001)
ML2(t,Complex2,T2,0.001)
length(Complex3[[1]])
Sd <- as.DNAbin(Complex3)
DMraw<- dist.dna(Sd,model="raw", as.matrix = TRUE)
DMraw <- DMraw * length(Complex3[[1]])
DMraw <- DMraw / 10000000
DMraw
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
setwd("~/Documents/root_node/Vac_Scholarship_R/Constrained_Tree_Topologies/Data")
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
Complex3 <- read.phyDat("Complex3.fa",format="fasta", type="DNA")
Complex3 <- read.phyDat("Complex3.fa",format="fasta", type="DNA")
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
Complex3 <- read.phyDat("Complex3.fa",format="fasta", type="DNA")
Complex3 <- read.phyDat("Complex3.fa",format="fasta", type="DNA")
n<- length(Complex3)
names<- c(rep(1:n))
for( i in 1:n) {
names[i] <- paste( i, 1, sep = ".")
}
names(Complex3) <- names
length(Complex3[[1]])
n<- length(Complex3)
n
n<- length(Complex3)
names<- c(rep(1:n))
for( i in 1:n) {
names[i] <- paste( i, 1, sep = ".")
}
names(Complex3) <- names
Complex2 <- Complex3[c(1,2)]
Complex3 <- read.phyDat("Complex3.fa",format="fasta", type="DNA")
length(Complex3[[1]])
Sd <- as.DNAbin(Complex3)
DMraw<- dist.dna(Sd,model="raw", as.matrix = TRUE)
DMraw <- DMraw * length(Complex3[[1]])
DMraw <- DMraw / 10000000
DMraw
Complex3 <- read.phyDat("Complex3.fa",format="fasta", type="DNA")
setwd("~/Documents/root_node/Vac_Scholarship_R/Constrained_Tree_Topologies/Data")
Complex3 <- read.phyDat("XXY.fa",format="fasta", type="DNA")
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
source('~/Documents/root_node/Vac_Scholarship_R/Constrained_Tree_Topologies/Testing_Trees_Functions.R', echo=TRUE)
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
setwd("~/Documents/root_node/Vac_Scholarship_R/Constrained_Tree_Topologies/Data")
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
Complex3 <- read.phyDat("Complex.fa",format="fasta", type="DNA")
source('~/Documents/root_node/Vac_Scholarship_R/Constrained_Tree_Topologies/calculations.R', echo=TRUE)
